<html>
<head>
<title>FBX Importer</title>
<script>

function load()
{
  var div = document.getElementById("error");
  div.innerHTML = "";

  var file = document.getElementById("file").value;
  var client = new XMLHttpRequest();
  client.open('GET', file);
  client.onload = function() { process(client.responseText); }
  client.send();
}

var States = {FindObjects: 1, FindTag: 2, ParseGeometry: 3, ParseModel: 4, ParseMaterial: 5, ParseConnections: 6, ParseTexture: 7 };
var groups = [];
var objects = { };
var curmesh = { type: "mesh" };
var curmodel = { type: "model" };
var curmaterial = { type: "material", models: [] };
var curTexture = { type: "texture" };

function done()
{
  for (id in objects) 
  {
    if (objects[id].type === "material") groups[groups.length] = objects[id];
    else if (objects[id].type === "model" && objects[id].mesh)
    {
      objects[id].mesh = bake(objects[id].mesh);
      objects[id].boundingbox = getBB(objects[id])
    }
  }

  var file = {};
  file.attributes = { 'POS': 0, 'TEX0': 12, 'NORM': 20 };
  file.groups = groups;

  // get full bb
  var bb = { };
  for (var g = 0; g < groups.length; ++g)
    for (var m = 0; m < groups[g].models.length; ++m)
    {
      var mbb = groups[g].models[m].boundingbox;
      if (!bb.min) bb.min = [mbb.min[0], mbb.min[1], mbb.min[2]];
      else
      {
        if (mbb.min[0] < bb.min[0]) bb.min[0] = mbb.min[0];
        if (mbb.min[1] < bb.min[1]) bb.min[1] = mbb.min[1];
        if (mbb.min[2] < bb.min[2]) bb.min[2] = mbb.min[2];
      }
      if (!bb.max) bb.max = [mbb.max[0], mbb.max[1], mbb.max[2]];
      else
      {
        if (mbb.max[0] > bb.max[0]) bb.max[0] = mbb.max[0];
        if (mbb.max[1] > bb.max[1]) bb.max[1] = mbb.max[1];
        if (mbb.max[2] > bb.max[2]) bb.max[2] = mbb.max[2];
      }
    }
  file.boundingbox = bb;

  var div = document.getElementById("output");
  div.innerHTML = "<textarea rows=20 cols=80>"+JSON.stringify(file)+"</textarea>";
}

  // bake mesh
  // create non-indexed vertex lists using the given data
  // determine how many verts are exactly the same via hashing?
  // if it is worth it, generate index buffer to optimize
Array.prototype.unique = function ()
{
  var unique = [];
  for (var i = 0; i < this.length; i++) {
    if (unique.indexOf(this[i]) == -1) unique.push(this[i]);
  }
  return unique;
};

function getBB(model)
{
  if (!model.translation) model.translation = [0, 0, 0];
  if (!model.scale) model.scale = [1, 1, 1];

  var bb = { min: [model.mesh.vertexs[0], model.mesh.vertexs[1], model.mesh.vertexs[2]], max: [model.mesh.vertexs[0], model.mesh.vertexs[1], model.mesh.vertexs[2]] };
  for (var i = 8; i < model.mesh.vertexs.length; i += 8)
  {
    if (model.mesh.vertexs[i + 0] < bb.min[0]) bb.min[0] = model.mesh.vertexs[i + 0];
    if (model.mesh.vertexs[i + 1] < bb.min[1]) bb.min[1] = model.mesh.vertexs[i + 1];
    if (model.mesh.vertexs[i + 2] < bb.min[2]) bb.min[2] = model.mesh.vertexs[i + 2];
    if (model.mesh.vertexs[i + 0] > bb.max[0]) bb.max[0] = model.mesh.vertexs[i + 0];
    if (model.mesh.vertexs[i + 1] > bb.max[1]) bb.max[1] = model.mesh.vertexs[i + 1];
    if (model.mesh.vertexs[i + 2] > bb.max[2]) bb.max[2] = model.mesh.vertexs[i + 2];
  }
  bb.min[0] = bb.min[0] * model.scale[0] + model.translation[0];
  bb.min[1] = bb.min[1] * model.scale[1] + model.translation[1];
  bb.min[2] = bb.min[2] * model.scale[2] + model.translation[2];
  bb.max[0] = bb.max[0] * model.scale[0] + model.translation[0];
  bb.max[1] = bb.max[1] * model.scale[1] + model.translation[1];
  bb.max[2] = bb.max[2] * model.scale[2] + model.translation[2];
  return bb;
}

function bake(mesh)
{
  var vertexs = [];
  var indexes = [];

  var vertexstring = [];  // the stringified vertex list uniq to cull duplicate verts
  var index = 0;
  var normal = 0;
  do {
    var vert = []
    var v = mesh.indexes[index] * 3;
    vert.push(mesh.vertexs[v]);
    vert.push(mesh.vertexs[v + 1]);
    vert.push(mesh.vertexs[v + 2]);
    var v2 = mesh.uvindex[index] * 2;
    vert.push(mesh.uv[v2]);
    vert.push(mesh.uv[v2 + 1]);
    if (mesh.mapping == 0)
    {
      vert.push(mesh.normals[normal]);
      vert.push(mesh.normals[normal + 1]);
      vert.push(mesh.normals[normal + 2]);
    }
    else
    {
      vert.push(mesh.normals[v]);
      vert.push(mesh.normals[v + 1]);
      vert.push(mesh.normals[v + 2]);
    }
    index += 1;
    normal += 3;
    vertexstring.push(JSON.stringify(vert));
  } while (index != mesh.indexes.length);

  // how many are the same?
  var uniq = vertexstring.unique();
  error("Info: mesh has " + vertexstring.length + " verts");
  error("Info: mesh has " + uniq.length + " unique verts");
  // convert this to an actual vertex list
  var vertexobj = [];
  for (var i = 0; i < uniq.length; ++i) vertexobj.push(JSON.parse(uniq[i]));
  for (var i = 0; i < vertexobj.length; ++i) for (var j = 0; j < 8; ++j) vertexs.push(parseFloat(vertexobj[i][j]));

  // use the vertexstring list as a key to build the index list
  //   to do this we need a convenience reverse lookup array
  var reverse = {};
  for (var i = 0; i < uniq.length; ++i) reverse[uniq[i]] = i;
  for (var i = 0; i < vertexstring.length; ++i) indexes.push(reverse[vertexstring[i]]);

  var ret = { vertexs: vertexs, indexes: indexes };
  return ret;
}

function save()
{
  if (curmesh.id)
  {
    objects[curmesh.id] = curmesh;
    curmesh = { type: "mesh" };
  }
  if (curmodel.id)
  {
    objects[curmodel.id] = curmodel;
    curmodel = { type: "model" };
  }
  if (curTexture.id)
  {
    objects[curTexture.id] = curTexture;
    curTexture = { type: "texture" };
  }
  if (curmaterial.id)
  {
    objects[curmaterial.id] = curmaterial;
    curmaterial = { type: "material", models: [] };
  }

}

function error(msg)
{
  var div = document.getElementById("error");
  div.innerHTML += msg + "<br>";
}

var lastmapping = 0;

function process(data)
{
  var lines = data.replace(/\r/g,"").split("\n");
  // hunt for objects
  var i = 0;
  var state = States.FindObjects;

  for (;i < lines.length; ++i) if (lines[i].indexOf("Objects: ") != -1) { state = States.FindTag; break; }
  if (state == States.FindObjects) { error("File is not an FBX file."); return; }

  // watch for geometry, model, material, connections
  for (; i < lines.length; ++i)
  {
    if (lines[i].indexOf("Geometry: ") != -1)
    {
      save();
      curmesh.id = lines[i].split(":")[1].split(",")[0].trim();
      lastmapping = 0;
      state = States.ParseGeometry;
    }
    else if (lines[i].indexOf("ShadingModel: ") != -1) {}
    else if (lines[i].indexOf("Model: ") != -1)
    {
      save();
      curmodel.id = lines[i].split(":")[1].split(",")[0].trim();
      curmodel.name = lines[i].replace("::",",").split(":")[1].split(",")[2].replace(/\"/g,"").trim();
      state = States.ParseModel;
    }
    else if (lines[i].indexOf("LayerElementMaterial: ") != -1) { }
    else if (lines[i].indexOf("Material: ") != -1)
    {
      save();
      curmaterial.id = lines[i].split(":")[1].split(",")[0].trim();
      curmaterial.name = lines[i].replace("::",",").split(":")[1].split(",")[2].replace(/\"/g,"").trim();
      state = States.ParseMaterial;
    }
    else if (lines[i].indexOf("Connections: ") != -1)
    {
      save();
      state = States.ParseConnections;
    }
    else if (lines[i].indexOf("Texture: ") != -1)
    {
      save();
      curTexture.id = lines[i].split(":")[1].split(",")[0].trim();
      state = States.ParseTexture;
    }

    if (state == States.ParseConnections)
    {
      if (lines[i].indexOf("C: ") != -1)
      {
        var values = lines[i].split(",");
        var obj1 = objects[values[1].trim()];
        var obj2 = objects[values[2].trim()];
        if (!obj1 || !obj2) continue;

        if (obj1.type === "mesh" && obj2.type === "model") obj2.mesh = obj1;
        else if (obj1.type === "material" && obj2.type === "model") obj1.models[obj1.models.length] = obj2;
        else if (obj2.type === "material" && obj1.type === "texture") obj2.texture = obj1.file;
    }
    }

    else if (state == States.ParseTexture)
    {
      if (lines[i].indexOf("RelativeFilename") != -1)
      {
        var values = lines[i].trim().split("\"");
        curTexture.file = values[1];
        error("Info: Required texture: " + curTexture.file);
      }
    }
    else if (state == States.ParseModel)
    {
      if (lines[i].indexOf("Lcl Translation") != -1)
      {
        var values = lines[i].trim().split(",");
        curmodel.translation = [parseFloat(values[4]), parseFloat(values[5]), parseFloat(values[6])];
      }
      else if (lines[i].indexOf("Lcl Scaling") != -1)
      {
        var values = lines[i].trim().split(",");
        curmodel.scale = [parseFloat(values[4]), parseFloat(values[5]), parseFloat(values[6])];
      }
    }

    else if (state == States.ParseMaterial)
    {
      if (lines[i].indexOf("P: ") != -1)
      {
        var values = lines[i].split(":")[1].trim().split(",");
        curmaterial[values[0].replace(/\"/g, "")] = values.slice(4, 7);
      }
    }

    else if (state == States.ParseGeometry)
    {
      if (lines[i].indexOf("Vertices: ") != -1)
      {
        if (curmesh.vertexs) { error("Error: multiple vertexes at line " + i); continue; }

        var num = lines[i].split("*")[1].split(" ")[0];
        var values = [];
        // get lines until values is num
        for (++i; i < lines.length; ++i)
        {
          if (lines[i].indexOf('}') != -1) break;
          var a = lines[i].indexOf('a:');
          if (a != -1) lines[i] = lines[i].substr(a + 3);
          values.pop();
          values = values.concat(lines[i].split(","));
          if (values.length == num) break;
        }
        curmesh.vertexs = values;
      }
      else if (lines[i].indexOf("PolygonVertexIndex: ") != -1)
      {
        if (curmesh.indexs) { error("Error: multiple indexes at line " + i); continue; }

        var num = lines[i].split("*")[1].split(" ")[0];
        var values = [];
        // get lines until values is num
        for (++i; i < lines.length; ++i)
        {
          if (lines[i].indexOf('}') != -1) break;
          var a = lines[i].indexOf('a:');
          if (a != -1) lines[i] = lines[i].substr(a + 3);
          values.pop();
          values = values.concat(lines[i].split(","));
          if (values.length == num) break;
        }
        // check that its trilist and flip the negative ones
        for (var j = 2; j < values.length; j += 3)
        {
          if (values[j] >= 0) { error("Error: mesh is not a triangle list at line " + i); break; }
          values[j] = (values[j] * -1) - 1;
        }
        curmesh.indexes = values;
      }
      else if (lines[i].indexOf("MappingInformationType: ") != -1)
      {
        if (lines[i].indexOf("ByVertice") != -1) lastmapping = 1;
        else lastmapping = 0;
      }
      else if (lines[i].indexOf("Normals: ") != -1)
      {
        if (curmesh.normals) { error("Error: multiple normals at line " + i); continue; }

        var num = lines[i].split("*")[1].split(" ")[0];
        var values = [];
        // get lines until values is num
        for (++i; i < lines.length; ++i)
        {
          if (lines[i].indexOf('}') != -1) break;
          var a = lines[i].indexOf('a:');
          if (a != -1) lines[i] = lines[i].substr(a + 3);
          values.pop();
          values = values.concat(lines[i].split(","));
          if (values.length == num) break;
        }
        curmesh.normals = values;
        curmesh.mapping = lastmapping;
      }
      else if (lines[i].indexOf("LayerElementUV: ") != -1) { }
      else if (lines[i].indexOf("UV: ") != -1)
      {
        if (curmesh.uv) { error("Error: multiple UVs at line " + i); continue; }

        var num = lines[i].split("*")[1].split(" ")[0];
        var uvvalues = [];
        var values = [];
        // get lines until values is num
        for (++i; i < lines.length; ++i)
        {
          if (lines[i].indexOf('}') != -1) break;
          var a = lines[i].indexOf('a:');
          if (a != -1) lines[i] = lines[i].substr(a + 3);
          uvvalues.pop();
          uvvalues = uvvalues.concat(lines[i].split(","));
          if (uvvalues.length == num) break;
        }
        curmesh.uv = uvvalues;
      }
      else if (lines[i].indexOf("UVIndex: ") != -1)
      {
        num = lines[i].split("*")[1].split(" ")[0];
        // get lines until values is num
        for (++i; i < lines.length; ++i)
        {
          if (lines[i].indexOf('}') != -1) break;
          var a = lines[i].indexOf('a:');
          if (a != -1) lines[i] = lines[i].substr(a + 3);
          values.pop();
          values = values.concat(lines[i].split(","));
          if (values.length == num) break;
        }
        curmesh.uvindex = values;
      }
    }
  }
  save();
  done();
}

</script>
</head>
<body>

ASCII FBX Mesh file (2013 format): <input id="file"></input>
<input type=button onClick="load();" value="Load"></input><br>
<input type="checkbox" id="uvs" checked />UVs
<input type="checkbox" id="normals" checked />Normals
<input type="checkbox" id="tangets"  />Tangents
<input type="checkbox" id="binormals"  />Binormals<br />
<input type="checkbox" id="animations"  />Animations<br />

<div id="error"></div>
<div id="output"></div>
<pre>
FBX importer

This outputs JSON in the following format:

[] array of materials
  material
    type = "material"
    name = (string)
    (various lighting properties)
    models = [] array of models
      model
        type = "model"
        name = (string)
        translation = (vec3)
        scaling = (vec3)
        mesh = (object)
          mesh
            type = "mesh"
            vertexs = [] array of float
            indexes = [] array of float
            uv = [] array of float
            normals = [] array of float

This format is intended to be a collections of meshes, grouped by material.

Upon loading, each mesh object should have its arrays of floats smushed into a single vertex array.
The vertex definition will be:
  position: 3 floats
  texcoord: 2 floats
  normal: 3 floats
Total vertex stride: 8 floats
Ideally, this fbx parser will do this part for you.

Pseudo WebGL code to handle this grouping is like this:

for each material
  create uniforms for lighting parameters
  set uniforms 
  locate material's texture
  set texture uniform
  for each model
    get translation and scaling vectors
    adjust the world matrixes accordingly
    set uniforms
    bind mesh buffer
    draw

TODO: 
- material texture filename?
- frames and such
- animations
</pre>

</body>
</html>
